package main

import (
	"bytes"
	"fmt"
	"strings"
)

// GenerateFlagsFile generates a complete flags file for a command
func GenerateFlagsFile(config *CommandConfig, schemas map[string]*Field) (string, []GenerationError, error) {
	var buf bytes.Buffer
	var errors []GenerationError

	// Check if we need fmt import (for JSON file input errors or enum union errors)
	needsFmt := false
	needsJSON := false
	for _, fc := range config.Fields {
		if fc.Category == CategoryJSONFileInput {
			needsFmt = true
			needsJSON = true
		}
		// Check for enum union types (anyOf with enum + string)
		if fc.Category == CategoryEnumFlag && fc.Field.Description != "" && len(fc.Field.Enum) > 0 {
			needsFmt = true
		}
	}

	// File header
	buf.WriteString("// Code generated by gen-flags DO NOT EDIT.\n")
	buf.WriteString("package cmd\n\n")
	buf.WriteString("import (\n")
	if needsFmt {
		buf.WriteString("\t\"encoding/json\"\n")
		buf.WriteString("\t\"fmt\"\n")
		buf.WriteString("\t\"os\"\n")
		buf.WriteString("\t\"strings\"\n")
		buf.WriteString("\n")
	}
	buf.WriteString("\t\"github.com/spf13/cobra\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/nottelabs/notte-cli/internal/api\"\n")
	buf.WriteString(")\n\n")

	// Add helper function for JSON file reading if needed
	if needsJSON {
		buf.WriteString("// readJSONFile reads JSON from a file path (supports @file.json syntax)\n")
		buf.WriteString("func readJSONFile(path string) (interface{}, error) {\n")
		buf.WriteString("\t// Remove @ prefix if present\n")
		buf.WriteString("\tfilePath := strings.TrimPrefix(path, \"@\")\n")
		buf.WriteString("\t\n")
		buf.WriteString("\tdata, err := os.ReadFile(filePath)\n")
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn nil, fmt.Errorf(\"failed to read file %s: %w\", filePath, err)\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\t\n")
		buf.WriteString("\tvar result interface{}\n")
		buf.WriteString("\tif err := json.Unmarshal(data, &result); err != nil {\n")
		buf.WriteString("\t\treturn nil, fmt.Errorf(\"failed to parse JSON from %s: %w\", filePath, err)\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\t\n")
		buf.WriteString("\treturn result, nil\n")
		buf.WriteString("}\n\n")
	}

	// Generate flag variables
	buf.WriteString(fmt.Sprintf("// %s command flags\n", config.Name))
	buf.WriteString("var (\n")

	for _, fc := range config.Fields {
		if fc.Category == CategorySkipped {
			// Silently skip - no error, no generation
			continue
		}

		if fc.Category == CategoryUnsupported {
			// Collect error
			err := BuildGenerationError(config.RequestBodyType, fc.Field.Name, fc.Field, schemas)
			err.Location = fmt.Sprintf("%s %s body", config.HTTPMethod, config.EndpointPath)
			errors = append(errors, err)
			continue
		}

		if fc.Category == CategoryFlattenedFlags {
			// Generate variables for sub-fields
			buf.WriteString(fmt.Sprintf("\t// Flattened: %s object\n", fc.FlagName))
			for _, subFC := range fc.SubFields {
				buf.WriteString(fmt.Sprintf("\t%s %s\n", subFC.VarName, subFC.GoType))
			}
		} else if fc.Category == CategoryJSONFileInput {
			// Generate string variable for JSON file path
			buf.WriteString(fmt.Sprintf("\t// JSON file input: %s\n", fc.FlagName))
			buf.WriteString(fmt.Sprintf("\t%s string\n", fc.VarName))
		} else {
			// Generate variable
			if fc.Field.Description != "" {
				buf.WriteString(fmt.Sprintf("\t// %s\n", fc.Field.Description))
			}
			buf.WriteString(fmt.Sprintf("\t%s %s\n", fc.VarName, fc.GoType))
		}
		buf.WriteString("\n")
	}

	buf.WriteString(")\n\n")

	// Generate register function
	if err := generateRegisterFunction(&buf, config); err != nil {
		return "", errors, err
	}

	// Generate build function
	if err := generateBuildFunction(&buf, config, schemas); err != nil {
		return "", errors, err
	}

	return buf.String(), errors, nil
}

func generateRegisterFunction(buf *bytes.Buffer, config *CommandConfig) error {
	buf.WriteString(fmt.Sprintf("// Register%sFlags registers all flags for %s command\n", config.Name, config.Name))
	buf.WriteString(fmt.Sprintf("func Register%sFlags(cmd *cobra.Command) {\n", config.Name))

	for _, fc := range config.Fields {
		if fc.Category == CategoryUnsupported || fc.Category == CategorySkipped {
			continue
		}

		if fc.Category == CategoryFlattenedFlags {
			// Register sub-fields
			buf.WriteString(fmt.Sprintf("\t// %s (flattened object)\n", fc.Field.Name))
			for _, subFC := range fc.SubFields {
				generateFlagRegistration(buf, subFC)
			}
		} else if fc.Category == CategoryJSONFileInput {
			// Register as string flag for JSON file path
			buf.WriteString(fmt.Sprintf("\tcmd.Flags().StringVar(&%s, \"%s-json\", \"\", \"%s configuration (JSON file path, e.g., @config.json)\")\n",
				fc.VarName, fc.FlagName, fc.FlagName))
		} else {
			generateFlagRegistration(buf, fc)
		}
	}

	buf.WriteString("}\n\n")
	return nil
}

func generateFlagRegistration(buf *bytes.Buffer, fc *FieldConfig) {
	defaultValue := getDefaultValue(fc)
	description := fc.Field.Description
	if description == "" {
		description = fc.FlagName
	}

	// Add enum values to description
	if fc.Category == CategoryEnumFlag && len(fc.Field.Enum) > 0 {
		description += fmt.Sprintf(" (%s)", strings.Join(fc.Field.Enum, ", "))
	}

	switch fc.FlagType {
	case "StringVar":
		buf.WriteString(fmt.Sprintf("\tcmd.Flags().StringVar(&%s, \"%s\", \"%s\", \"%s\")\n",
			fc.VarName, fc.FlagName, defaultValue, description))
	case "IntVar":
		buf.WriteString(fmt.Sprintf("\tcmd.Flags().IntVar(&%s, \"%s\", %s, \"%s\")\n",
			fc.VarName, fc.FlagName, defaultValue, description))
	case "BoolVar":
		buf.WriteString(fmt.Sprintf("\tcmd.Flags().BoolVar(&%s, \"%s\", %s, \"%s\")\n",
			fc.VarName, fc.FlagName, defaultValue, description))
	case "Float64Var":
		buf.WriteString(fmt.Sprintf("\tcmd.Flags().Float64Var(&%s, \"%s\", %s, \"%s\")\n",
			fc.VarName, fc.FlagName, defaultValue, description))
	case "StringSliceVar":
		buf.WriteString(fmt.Sprintf("\tcmd.Flags().StringSliceVar(&%s, \"%s\", []string{}, \"%s (repeatable)\")\n",
			fc.VarName, fc.FlagName, description))
	}
}

func getDefaultValue(fc *FieldConfig) string {
	if fc.Field.Default != nil {
		return fmt.Sprintf("%v", fc.Field.Default)
	}

	switch fc.Field.Type {
	case "string":
		return ""
	case "integer":
		return "0"
	case "boolean":
		return "false"
	case "number":
		return "0.0"
	default:
		return ""
	}
}

func generateBuildFunction(buf *bytes.Buffer, config *CommandConfig, schemas map[string]*Field) error {
	buf.WriteString(fmt.Sprintf("// Build%sRequest builds the API request from CLI flags\n", config.Name))
	buf.WriteString(fmt.Sprintf("func Build%sRequest(cmd *cobra.Command) (*api.%s, error) {\n", config.Name, config.RequestBodyType))
	buf.WriteString(fmt.Sprintf("\tbody := &api.%s{}\n\n", config.RequestBodyType))

	for _, fc := range config.Fields {
		if fc.Category == CategoryUnsupported || fc.Category == CategorySkipped {
			continue
		}

		switch fc.Category {
		case CategorySimpleFlag:
			generateSimpleFieldMapping(buf, fc)
		case CategoryEnumFlag:
			generateEnumFieldMapping(buf, fc, config)
		case CategoryFlattenedFlags:
			generateFlattenedFieldMapping(buf, fc, config, schemas)
		case CategoryRepeatedFlag:
			generateRepeatedFieldMapping(buf, fc)
		case CategoryJSONFileInput:
			generateJSONFileInputMapping(buf, fc)
		}
	}

	buf.WriteString("\treturn body, nil\n")
	buf.WriteString("}\n")

	return nil
}

func generateJSONFileInputMapping(buf *bytes.Buffer, fc *FieldConfig) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	buf.WriteString(fmt.Sprintf("\t// %s (JSON file input)\n", fc.Field.Name))
	buf.WriteString(fmt.Sprintf("\tif %s != \"\" {\n", fc.VarName))
	buf.WriteString(fmt.Sprintf("\t\tdata, err := readJSONFile(%s)\n", fc.VarName))
	buf.WriteString("\t\tif err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"failed to read %s: %%w\", err)\n", fc.FlagName))
	buf.WriteString("\t\t}\n")
	buf.WriteString(fmt.Sprintf("\t\tbody.%s = data\n", apiFieldName))
	buf.WriteString("\t}\n\n")
}

func generateSimpleFieldMapping(buf *bytes.Buffer, fc *FieldConfig) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	if fc.Field.Type == "boolean" || fc.Field.Required {
		// For booleans and required fields, check if flag was changed
		buf.WriteString(fmt.Sprintf("\tif cmd.Flags().Changed(\"%s\") {\n", fc.FlagName))
		buf.WriteString(fmt.Sprintf("\t\tbody.%s = &%s\n", apiFieldName, fc.VarName))
		buf.WriteString("\t}\n\n")
	} else {
		// For optional fields, check if non-zero
		switch fc.Field.Type {
		case "string":
			buf.WriteString(fmt.Sprintf("\tif %s != \"\" {\n", fc.VarName))
			buf.WriteString(fmt.Sprintf("\t\tbody.%s = &%s\n", apiFieldName, fc.VarName))
			buf.WriteString("\t}\n\n")
		case "integer", "number":
			buf.WriteString(fmt.Sprintf("\tif %s > 0 {\n", fc.VarName))
			buf.WriteString(fmt.Sprintf("\t\tbody.%s = &%s\n", apiFieldName, fc.VarName))
			buf.WriteString("\t}\n\n")
		}
	}
}

func generateEnumFieldMapping(buf *bytes.Buffer, fc *FieldConfig, config *CommandConfig) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	// Check if this is a union type (anyOf with enum + string)
	// In this case, we need to use the From*1 method
	isUnionType := fc.Field.Description != "" && len(fc.Field.Enum) > 0

	buf.WriteString(fmt.Sprintf("\tif %s != \"\" {\n", fc.VarName))

	if isUnionType {
		// Union type - use From*1 method to set string value
		unionTypeName := fmt.Sprintf("%s_%s", config.RequestBodyType, apiFieldName)
		buf.WriteString(fmt.Sprintf("\t\tvar val api.%s\n", unionTypeName))
		buf.WriteString(fmt.Sprintf("\t\tif err := val.From%s%s1(%s); err != nil {\n",
			config.RequestBodyType, apiFieldName, fc.VarName))
		buf.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"invalid %s: %%w\", err)\n", fc.FlagName))
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\tbody.%s = &val\n", apiFieldName))
	} else {
		// Simple enum type - direct cast
		enumTypeName := fmt.Sprintf("%s%s", config.RequestBodyType, apiFieldName)
		buf.WriteString(fmt.Sprintf("\t\tval := api.%s(%s)\n", enumTypeName, fc.VarName))
		buf.WriteString(fmt.Sprintf("\t\tbody.%s = &val\n", apiFieldName))
	}

	buf.WriteString("\t}\n\n")
}

func generateFlattenedFieldMapping(buf *bytes.Buffer, fc *FieldConfig, config *CommandConfig, schemas map[string]*Field) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	// Resolve the struct type
	structTypeName := fc.Field.Ref
	if structTypeName == "" {
		structTypeName = apiFieldName
	}

	// Check if any sub-field is set
	var conditions []string
	for _, subFC := range fc.SubFields {
		if subFC.Field.Type == "string" {
			conditions = append(conditions, fmt.Sprintf("%s != \"\"", subFC.VarName))
		} else {
			conditions = append(conditions, fmt.Sprintf("cmd.Flags().Changed(\"%s\")", subFC.FlagName))
		}
	}

	buf.WriteString(fmt.Sprintf("\t// %s (flattened)\n", fc.Field.Name))
	buf.WriteString(fmt.Sprintf("\tif %s {\n", strings.Join(conditions, " || ")))
	buf.WriteString(fmt.Sprintf("\t\tbody.%s = api.%s{\n", apiFieldName, structTypeName))

	for _, subFC := range fc.SubFields {
		subAPIFieldName := toCamelCase(subFC.Field.JSONName)
		if subAPIFieldName == "" {
			subAPIFieldName = toCamelCase(subFC.Field.Name)
		}

		// For required fields in API, assign directly; for optional fields, take address
		if subFC.Field.Required {
			buf.WriteString(fmt.Sprintf("\t\t\t%s: %s,\n", subAPIFieldName, subFC.VarName))
		} else {
			buf.WriteString(fmt.Sprintf("\t\t\t%s: &%s,\n", subAPIFieldName, subFC.VarName))
		}
	}

	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n\n")
}

func generateRepeatedFieldMapping(buf *bytes.Buffer, fc *FieldConfig) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	buf.WriteString(fmt.Sprintf("\tif len(%s) > 0 {\n", fc.VarName))

	if fc.Field.Items.Type == "string" {
		// For []string, we can assign directly or convert to []interface{}
		// Check if the API expects []string or []interface{}
		buf.WriteString(fmt.Sprintf("\t\t// Convert string slice to interface slice\n"))
		buf.WriteString(fmt.Sprintf("\t\targs := make([]interface{}, len(%s))\n", fc.VarName))
		buf.WriteString(fmt.Sprintf("\t\tfor i, arg := range %s {\n", fc.VarName))
		buf.WriteString("\t\t\targs[i] = arg\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\tbody.%s = &args\n", apiFieldName))
	} else {
		buf.WriteString(fmt.Sprintf("\t\tbody.%s = &%s\n", apiFieldName, fc.VarName))
	}

	buf.WriteString("\t}\n\n")
}
