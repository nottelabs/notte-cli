package main

import (
	"bytes"
	"fmt"
	"strings"
)

// GenerateFlagsFile generates a complete flags file for a command
func GenerateFlagsFile(config *CommandConfig, schemas map[string]*Field) (string, []GenerationError, error) {
	var buf bytes.Buffer
	var errors []GenerationError

	// Check if we need fmt import (for errors in validation)
	needsFmt := false
	needsJSON := false
	for _, fc := range config.Fields {
		if fc.Category == CategoryJSONFileInput {
			needsFmt = true
			needsJSON = true
		}
		// Check for actual union types (anyOf with enum + string), not simple enums
		if fc.Category == CategoryEnumFlag && fc.Field.IsUnionType {
			needsFmt = true
		}
		// Required string fields need fmt for validation errors
		if fc.Field.Required && fc.Field.Type == "string" {
			needsFmt = true
		}
		// Flattened fields with required sub-fields need fmt for validation
		if fc.Category == CategoryFlattenedFlags {
			for _, subFC := range fc.SubFields {
				if subFC.Field.Required && subFC.Field.Type == "string" {
					needsFmt = true
					break
				}
			}
		}
	}

	// File header
	buf.WriteString("// Code generated by gen-flags DO NOT EDIT.\n")
	buf.WriteString("package cmd\n\n")
	buf.WriteString("import (\n")
	if needsJSON {
		buf.WriteString("\t\"encoding/json\"\n")
	}
	if needsFmt {
		buf.WriteString("\t\"fmt\"\n")
	}
	if needsJSON {
		buf.WriteString("\t\"os\"\n")
		buf.WriteString("\t\"strings\"\n")
	}
	if needsFmt || needsJSON {
		buf.WriteString("\n")
	}
	buf.WriteString("\t\"github.com/spf13/cobra\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/nottelabs/notte-cli/internal/api\"\n")
	buf.WriteString(")\n\n")

	// Add helper function for JSON file reading if needed
	if needsJSON {
		buf.WriteString("// readJSONFile reads JSON from a file path (supports @file.json syntax)\n")
		buf.WriteString("func readJSONFile(path string) (interface{}, error) {\n")
		buf.WriteString("\t// Remove @ prefix if present\n")
		buf.WriteString("\tfilePath := strings.TrimPrefix(path, \"@\")\n")
		buf.WriteString("\t\n")
		buf.WriteString("\tdata, err := os.ReadFile(filePath)\n")
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn nil, fmt.Errorf(\"failed to read file %s: %w\", filePath, err)\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\t\n")
		buf.WriteString("\tvar result interface{}\n")
		buf.WriteString("\tif err := json.Unmarshal(data, &result); err != nil {\n")
		buf.WriteString("\t\treturn nil, fmt.Errorf(\"failed to parse JSON from %s: %w\", filePath, err)\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\t\n")
		buf.WriteString("\treturn result, nil\n")
		buf.WriteString("}\n\n")
	}

	// Generate flag variables
	fmt.Fprintf(&buf, "// %s command flags\n", config.Name)
	buf.WriteString("var (\n")

	for _, fc := range config.Fields {
		if fc.Category == CategorySkipped {
			// Silently skip - no error, no generation
			continue
		}

		if fc.Category == CategoryUnsupported {
			// Collect error
			err := BuildGenerationError(config.RequestBodyType, fc.Field.Name, fc.Field, schemas)
			err.Location = fmt.Sprintf("%s %s body", config.HTTPMethod, config.EndpointPath)
			errors = append(errors, err)
			continue
		}

		switch fc.Category {
		case CategoryFlattenedFlags:
			// Generate variables for sub-fields
			fmt.Fprintf(&buf, "\t// Flattened: %s object\n", fc.FlagName)
			for _, subFC := range fc.SubFields {
				fmt.Fprintf(&buf, "\t%s %s\n", subFC.VarName, subFC.GoType)
			}
		case CategoryJSONFileInput:
			// Generate string variable for JSON file path
			fmt.Fprintf(&buf, "\t// JSON file input: %s\n", fc.FlagName)
			fmt.Fprintf(&buf, "\t%s string\n", fc.VarName)
		default:
			// Generate variable
			if fc.Field.Description != "" {
				fmt.Fprintf(&buf, "\t// %s\n", fc.Field.Description)
			}
			fmt.Fprintf(&buf, "\t%s %s\n", fc.VarName, fc.GoType)
		}
		buf.WriteString("\n")
	}

	buf.WriteString(")\n\n")

	// Generate register function
	if err := generateRegisterFunction(&buf, config); err != nil {
		return "", errors, err
	}

	// Generate build function
	if err := generateBuildFunction(&buf, config, schemas); err != nil {
		return "", errors, err
	}

	return buf.String(), errors, nil
}

func generateRegisterFunction(buf *bytes.Buffer, config *CommandConfig) error {
	fmt.Fprintf(buf, "// Register%sFlags registers all flags for %s command\n", config.Name, config.Name)
	fmt.Fprintf(buf, "func Register%sFlags(cmd *cobra.Command) {\n", config.Name)

	for _, fc := range config.Fields {
		if fc.Category == CategoryUnsupported || fc.Category == CategorySkipped {
			continue
		}

		switch fc.Category {
		case CategoryFlattenedFlags:
			// Register sub-fields
			fmt.Fprintf(buf, "\t// %s (flattened object)\n", fc.Field.Name)
			for _, subFC := range fc.SubFields {
				generateFlagRegistration(buf, subFC)
			}
		case CategoryJSONFileInput:
			// Register as string flag for JSON file path
			fmt.Fprintf(buf, "\tcmd.Flags().StringVar(&%s, \"%s-json\", \"\", \"%s configuration (JSON file path, e.g., @config.json)\")\n",
				fc.VarName, fc.FlagName, fc.FlagName)
		default:
			generateFlagRegistration(buf, fc)
		}
	}

	buf.WriteString("}\n\n")
	return nil
}

func generateFlagRegistration(buf *bytes.Buffer, fc *FieldConfig) {
	defaultValue := getDefaultValue(fc)
	description := fc.Field.Description
	if description == "" {
		description = fc.FlagName
	}

	// Add enum values to description
	if fc.Category == CategoryEnumFlag && len(fc.Field.Enum) > 0 {
		description += fmt.Sprintf(" (%s)", strings.Join(fc.Field.Enum, ", "))
	}

	switch fc.FlagType {
	case "StringVar":
		fmt.Fprintf(buf, "\tcmd.Flags().StringVar(&%s, \"%s\", \"%s\", \"%s\")\n",
			fc.VarName, fc.FlagName, defaultValue, description)
	case "IntVar":
		fmt.Fprintf(buf, "\tcmd.Flags().IntVar(&%s, \"%s\", %s, \"%s\")\n",
			fc.VarName, fc.FlagName, defaultValue, description)
	case "BoolVar":
		fmt.Fprintf(buf, "\tcmd.Flags().BoolVar(&%s, \"%s\", %s, \"%s\")\n",
			fc.VarName, fc.FlagName, defaultValue, description)
	case "Float64Var":
		fmt.Fprintf(buf, "\tcmd.Flags().Float64Var(&%s, \"%s\", %s, \"%s\")\n",
			fc.VarName, fc.FlagName, defaultValue, description)
	case "StringSliceVar":
		fmt.Fprintf(buf, "\tcmd.Flags().StringSliceVar(&%s, \"%s\", []string{}, \"%s (repeatable)\")\n",
			fc.VarName, fc.FlagName, description)
	}
}

func getDefaultValue(fc *FieldConfig) string {
	if fc.Field.Default != nil {
		return fmt.Sprintf("%v", fc.Field.Default)
	}

	switch fc.Field.Type {
	case "string":
		return ""
	case "integer":
		return "0"
	case "boolean":
		return "false"
	case "number":
		return "0.0"
	default:
		return ""
	}
}

func generateBuildFunction(buf *bytes.Buffer, config *CommandConfig, schemas map[string]*Field) error {
	fmt.Fprintf(buf, "// Build%sRequest builds the API request from CLI flags\n", config.Name)
	fmt.Fprintf(buf, "func Build%sRequest(cmd *cobra.Command) (*api.%s, error) {\n", config.Name, config.RequestBodyType)
	fmt.Fprintf(buf, "\tbody := &api.%s{}\n\n", config.RequestBodyType)

	for _, fc := range config.Fields {
		if fc.Category == CategoryUnsupported || fc.Category == CategorySkipped {
			continue
		}

		switch fc.Category {
		case CategorySimpleFlag:
			generateSimpleFieldMapping(buf, fc)
		case CategoryEnumFlag:
			generateEnumFieldMapping(buf, fc, config)
		case CategoryFlattenedFlags:
			generateFlattenedFieldMapping(buf, fc, config, schemas)
		case CategoryRepeatedFlag:
			generateRepeatedFieldMapping(buf, fc)
		case CategoryJSONFileInput:
			generateJSONFileInputMapping(buf, fc)
		}
	}

	buf.WriteString("\treturn body, nil\n")
	buf.WriteString("}\n")

	return nil
}

func generateJSONFileInputMapping(buf *bytes.Buffer, fc *FieldConfig) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	fmt.Fprintf(buf, "\t// %s (JSON file input)\n", fc.Field.Name)
	fmt.Fprintf(buf, "\tif %s != \"\" {\n", fc.VarName)
	fmt.Fprintf(buf, "\t\tdata, err := readJSONFile(%s)\n", fc.VarName)
	buf.WriteString("\t\tif err != nil {\n")
	fmt.Fprintf(buf, "\t\t\treturn nil, fmt.Errorf(\"failed to read %s: %%w\", err)\n", fc.FlagName)
	buf.WriteString("\t\t}\n")
	fmt.Fprintf(buf, "\t\tbody.%s = data\n", apiFieldName)
	buf.WriteString("\t}\n\n")
}

func generateSimpleFieldMapping(buf *bytes.Buffer, fc *FieldConfig) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	// Required fields in API are non-pointer types, assign directly
	// Optional fields are pointer types, take address
	assignOp := "&" + fc.VarName
	if fc.Field.Required {
		assignOp = fc.VarName
	}

	if fc.Field.Type == "boolean" {
		// For booleans, check if flag was changed
		fmt.Fprintf(buf, "\tif cmd.Flags().Changed(\"%s\") {\n", fc.FlagName)
		fmt.Fprintf(buf, "\t\tbody.%s = %s\n", apiFieldName, assignOp)
		buf.WriteString("\t}\n\n")
	} else if fc.Field.Required {
		// For required fields, validate non-empty for strings
		fmt.Fprintf(buf, "\tif cmd.Flags().Changed(\"%s\") {\n", fc.FlagName)
		if fc.Field.Type == "string" {
			fmt.Fprintf(buf, "\t\tif %s == \"\" {\n", fc.VarName)
			fmt.Fprintf(buf, "\t\t\treturn nil, fmt.Errorf(\"--%s cannot be empty\")\n", fc.FlagName)
			buf.WriteString("\t\t}\n")
		}
		fmt.Fprintf(buf, "\t\tbody.%s = %s\n", apiFieldName, assignOp)
		buf.WriteString("\t}\n\n")
	} else {
		// For optional fields, check if non-zero
		switch fc.Field.Type {
		case "string":
			fmt.Fprintf(buf, "\tif %s != \"\" {\n", fc.VarName)
			fmt.Fprintf(buf, "\t\tbody.%s = &%s\n", apiFieldName, fc.VarName)
			buf.WriteString("\t}\n\n")
		case "integer", "number":
			fmt.Fprintf(buf, "\tif %s > 0 {\n", fc.VarName)
			fmt.Fprintf(buf, "\t\tbody.%s = &%s\n", apiFieldName, fc.VarName)
			buf.WriteString("\t}\n\n")
		}
	}
}

func generateEnumFieldMapping(buf *bytes.Buffer, fc *FieldConfig, config *CommandConfig) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	fmt.Fprintf(buf, "\tif %s != \"\" {\n", fc.VarName)

	if fc.Field.IsUnionType {
		// Union type (anyOf with enum + string) - use From*1 method to set string value
		unionTypeName := fmt.Sprintf("%s_%s", config.RequestBodyType, apiFieldName)
		fmt.Fprintf(buf, "\t\tvar val api.%s\n", unionTypeName)
		fmt.Fprintf(buf, "\t\tif err := val.From%s%s1(%s); err != nil {\n",
			config.RequestBodyType, apiFieldName, fc.VarName)
		fmt.Fprintf(buf, "\t\t\treturn nil, fmt.Errorf(\"invalid %s: %%w\", err)\n", fc.FlagName)
		buf.WriteString("\t\t}\n")
		fmt.Fprintf(buf, "\t\tbody.%s = &val\n", apiFieldName)
	} else {
		// Simple enum type - direct cast
		enumTypeName := fmt.Sprintf("%s%s", config.RequestBodyType, apiFieldName)
		fmt.Fprintf(buf, "\t\tval := api.%s(%s)\n", enumTypeName, fc.VarName)
		fmt.Fprintf(buf, "\t\tbody.%s = &val\n", apiFieldName)
	}

	buf.WriteString("\t}\n\n")
}

func generateFlattenedFieldMapping(buf *bytes.Buffer, fc *FieldConfig, config *CommandConfig, schemas map[string]*Field) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	// Resolve the struct type (convert to valid Go identifier by removing hyphens)
	structTypeName := fc.Field.Ref
	if structTypeName == "" {
		structTypeName = apiFieldName
	}
	// Convert hyphenated names to CamelCase (e.g., "CredentialsDict-Input" -> "CredentialsDictInput")
	structTypeName = strings.ReplaceAll(structTypeName, "-", "")

	// Build conditions for required and optional fields
	var requiredConditions []string
	var optionalConditions []string
	for _, subFC := range fc.SubFields {
		if subFC.Field.Required && subFC.Field.Type == "string" {
			requiredConditions = append(requiredConditions, fmt.Sprintf("%s != \"\"", subFC.VarName))
		} else if subFC.Field.Type == "string" {
			optionalConditions = append(optionalConditions, fmt.Sprintf("%s != \"\"", subFC.VarName))
		} else {
			optionalConditions = append(optionalConditions, fmt.Sprintf("cmd.Flags().Changed(\"%s\")", subFC.FlagName))
		}
	}

	// If there are required fields, validate they're provided when optional fields are set
	var condition string
	if len(requiredConditions) > 0 {
		condition = strings.Join(requiredConditions, " && ")
		// Add validation: error if optional fields set without required fields
		if len(optionalConditions) > 0 {
			// Collect required flag names for error message
			var requiredFlagNames []string
			for _, subFC := range fc.SubFields {
				if subFC.Field.Required && subFC.Field.Type == "string" {
					requiredFlagNames = append(requiredFlagNames, "--"+subFC.FlagName)
				}
			}
			optionalCond := strings.Join(optionalConditions, " || ")
			fmt.Fprintf(buf, "\t// %s: validate required fields when optional fields are provided\n", fc.Field.Name)
			fmt.Fprintf(buf, "\tif (%s) && !(%s) {\n", optionalCond, condition)
			fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"%s requires %s to be set\")\n",
				fc.FlagName, strings.Join(requiredFlagNames, ", "))
			buf.WriteString("\t}\n\n")
		}
	} else {
		// No required fields - use OR for any field being set
		condition = strings.Join(optionalConditions, " || ")
	}

	fmt.Fprintf(buf, "\t// %s (flattened) - only set if required fields are provided\n", fc.Field.Name)
	fmt.Fprintf(buf, "\tif %s {\n", condition)
	// Optional flattened fields are pointers in the API, required ones are not
	if fc.Field.Required {
		fmt.Fprintf(buf, "\t\tbody.%s = api.%s{\n", apiFieldName, structTypeName)
	} else {
		fmt.Fprintf(buf, "\t\tbody.%s = &api.%s{\n", apiFieldName, structTypeName)
	}

	for _, subFC := range fc.SubFields {
		subAPIFieldName := toCamelCase(subFC.Field.JSONName)
		if subAPIFieldName == "" {
			subAPIFieldName = toCamelCase(subFC.Field.Name)
		}

		// For required fields in API, assign directly; for optional fields, take address
		if subFC.Field.Required {
			fmt.Fprintf(buf, "\t\t\t%s: %s,\n", subAPIFieldName, subFC.VarName)
		} else {
			fmt.Fprintf(buf, "\t\t\t%s: &%s,\n", subAPIFieldName, subFC.VarName)
		}
	}

	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n\n")
}

func generateRepeatedFieldMapping(buf *bytes.Buffer, fc *FieldConfig) {
	apiFieldName := toCamelCase(fc.Field.JSONName)
	if apiFieldName == "" {
		apiFieldName = toCamelCase(fc.Field.Name)
	}

	fmt.Fprintf(buf, "\tif len(%s) > 0 {\n", fc.VarName)
	// Pass the slice directly as a pointer - API expects *[]string or similar
	fmt.Fprintf(buf, "\t\tbody.%s = &%s\n", apiFieldName, fc.VarName)

	buf.WriteString("\t}\n\n")
}
